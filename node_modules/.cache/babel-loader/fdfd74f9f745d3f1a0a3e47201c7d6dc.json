{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Statement = void 0;\n\nconst format_error_1 = require(\"./utils/format-error\");\n/**\n * Promisified wrapper for the sqlite3#Statement interface.\n */\n\n\nclass Statement {\n  constructor(stmt) {\n    this.stmt = stmt;\n  }\n  /**\n   * Returns the underlying sqlite3 Statement instance\n   */\n\n\n  getStatementInstance() {\n    return this.stmt;\n  }\n  /**\n   * Binds parameters to the prepared statement.\n   *\n   * Binding parameters with this function completely resets the statement object and row cursor\n   * and removes all previously bound parameters, if any.\n   */\n\n\n  bind() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    return new Promise((resolve, reject) => {\n      this.stmt.bind(...params, err => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n\n        resolve();\n      });\n    });\n  }\n  /**\n   * Resets the row cursor of the statement and preserves the parameter bindings.\n   * Use this function to re-execute the same query with the same bindings.\n   */\n\n\n  reset() {\n    return new Promise(resolve => {\n      this.stmt.reset(() => {\n        resolve();\n      });\n    });\n  }\n  /**\n   * Finalizes the statement. This is typically optional, but if you experience long delays before\n   * the next query is executed, explicitly finalizing your statement might be necessary.\n   * This might be the case when you run an exclusive query (see section Control Flow).\n   * After the statement is finalized, all further function calls on that statement object\n   * will throw errors.\n   */\n\n\n  finalize() {\n    return new Promise((resolve, reject) => {\n      this.stmt.finalize(err => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n\n        resolve();\n      });\n    });\n  }\n  /**\n   * Binds parameters and executes the statement.\n   *\n   * If you specify bind parameters, they will be bound to the statement before it is executed.\n   * Note that the bindings and the row cursor are reset when you specify even a single bind parameter.\n   *\n   * The execution behavior is identical to the Database#run method with the difference that the\n   * statement will not be finalized after it is run. This means you can run it multiple times.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   */\n\n\n  run() {\n    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n\n    return new Promise((resolve, reject) => {\n      const stmt = this;\n      this.stmt.run(...params, function (err) {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n\n        resolve({\n          stmt,\n          lastID: this.lastID,\n          changes: this.changes\n        });\n      });\n    });\n  }\n  /**\n   * Binds parameters, executes the statement and retrieves the first result row.\n   * The parameters are the same as the Statement#run function, with the following differences:\n   *\n   * Using this method can leave the database locked, as the database awaits further\n   * calls to Statement#get to retrieve subsequent rows. To inform the database that you\n   * are finished retrieving rows, you should either finalize (with Statement#finalize)\n   * or reset (with Statement#reset) the statement.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   */\n\n\n  get() {\n    for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      params[_key3] = arguments[_key3];\n    }\n\n    return new Promise((resolve, reject) => {\n      this.stmt.get(...params, (err, row) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n\n        resolve(row);\n      });\n    });\n  }\n  /**\n   * Binds parameters, executes the statement and calls the callback with all result rows.\n   * The parameters are the same as the Statement#run function, with the following differences:\n   *\n   * If the result set is empty, it will resolve to an empty array, otherwise it contains an\n   * object for each result row which in turn contains the values of that row.\n   * Like with Statement#run, the statement will not be finalized after executing this function.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   *\n   * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n   */\n\n\n  all() {\n    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      params[_key4] = arguments[_key4];\n    }\n\n    return new Promise((resolve, reject) => {\n      this.stmt.all(...params, (err, rows) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n\n        resolve(rows);\n      });\n    });\n  }\n\n  each() {\n    for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      params[_key5] = arguments[_key5];\n    }\n\n    return new Promise((resolve, reject) => {\n      const callback = params.pop();\n\n      if (!callback || typeof callback !== 'function') {\n        throw new Error('sqlite: Last param of Statement#each() must be a callback function');\n      }\n\n      if (params.length > 0) {\n        const positional = params.pop();\n\n        if (typeof positional === 'function') {\n          throw new Error('sqlite: Statement#each() should only have a single callback defined. See readme for usage.');\n        }\n\n        params.push(positional);\n      }\n\n      this.stmt.each(...params, (err, row) => {\n        if (err) {\n          return callback((0, format_error_1.formatError)(err), null);\n        }\n\n        callback(null, row);\n      }, (err, count) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n\n        resolve(count);\n      });\n    });\n  }\n\n}\n\nexports.Statement = Statement;","map":{"version":3,"mappings":";;;;;;;AAEA;AAEA;;;;;AAGA,MAAaA,SAAb,CAAsB;EAGpBC,YAAaC,IAAb,EAAoB;IAClB,KAAKA,IAAL,GAAYA,IAAZ;EACD;EAED;;;;;EAGAC,oBAAoB;IAClB,OAAO,KAAKD,IAAZ;EACD;EAED;;;;;;;;EAMAE,IAAI,GAAkB;IAAA,kCAAbC,MAAa;MAAbA,MAAa;IAAA;;IACpB,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,KAAKN,IAAL,CAAUE,IAAV,CAAe,GAAGC,MAAlB,EAA0BI,GAAG,IAAG;QAC9B,IAAIA,GAAJ,EAAS;UACP,OAAOD,MAAM,CAAC,gCAAYC,GAAZ,CAAD,CAAb;QACD;;QAEDF,OAAO;MACR,CAND;IAOD,CARM,CAAP;EASD;EAED;;;;;;EAIAG,KAAK;IACH,OAAO,IAAIJ,OAAJ,CAAYC,OAAO,IAAG;MAC3B,KAAKL,IAAL,CAAUQ,KAAV,CAAgB,MAAK;QACnBH,OAAO;MACR,CAFD;IAGD,CAJM,CAAP;EAKD;EAED;;;;;;;;;EAOAI,QAAQ;IACN,OAAO,IAAIL,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,KAAKN,IAAL,CAAUS,QAAV,CAAmBF,GAAG,IAAG;QACvB,IAAIA,GAAJ,EAAS;UACP,OAAOD,MAAM,CAAC,gCAAYC,GAAZ,CAAD,CAAb;QACD;;QAEDF,OAAO;MACR,CAND;IAOD,CARM,CAAP;EASD;EAED;;;;;;;;;;;;;;;;;EAeAK,GAAG,GAAkB;IAAA,mCAAbP,MAAa;MAAbA,MAAa;IAAA;;IACnB,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,MAAMN,IAAI,GAAG,IAAb;MAEA,KAAKA,IAAL,CAAUU,GAAV,CAAc,GAAGP,MAAjB,EAAyB,UAAUI,GAAV,EAAa;QACpC,IAAIA,GAAJ,EAAS;UACP,OAAOD,MAAM,CAAC,gCAAYC,GAAZ,CAAD,CAAb;QACD;;QAEDF,OAAO,CAAC;UACNL,IADM;UAENW,MAAM,EAAE,KAAKA,MAFP;UAGNC,OAAO,EAAE,KAAKA;QAHR,CAAD,CAAP;MAKD,CAVD;IAWD,CAdM,CAAP;EAeD;EAED;;;;;;;;;;;;;;;;;EAeAC,GAAG,GAA2B;IAAA,mCAAbV,MAAa;MAAbA,MAAa;IAAA;;IAC5B,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,KAAKN,IAAL,CAAUa,GAAV,CAAc,GAAGV,MAAjB,EAAyB,CAACI,GAAD,EAAMO,GAAN,KAAiB;QACxC,IAAIP,GAAJ,EAAS;UACP,OAAOD,MAAM,CAAC,gCAAYC,GAAZ,CAAD,CAAb;QACD;;QAEDF,OAAO,CAACS,GAAD,CAAP;MACD,CAND;IAOD,CARM,CAAP;EASD;EAED;;;;;;;;;;;;;;;;;;EAgBAC,GAAG,GAA6B;IAAA,mCAAbZ,MAAa;MAAbA,MAAa;IAAA;;IAC9B,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,KAAKN,IAAL,CAAUe,GAAV,CAAc,GAAGZ,MAAjB,EAAyB,CAACI,GAAD,EAAMS,IAAN,KAAkB;QACzC,IAAIT,GAAJ,EAAS;UACP,OAAOD,MAAM,CAAC,gCAAYC,GAAZ,CAAD,CAAb;QACD;;QAEDF,OAAO,CAACW,IAAD,CAAP;MACD,CAND;IAOD,CARM,CAAP;EASD;;EAyCDC,IAAI,GAA2B;IAAA,mCAAbd,MAAa;MAAbA,MAAa;IAAA;;IAC7B,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACrC,MAAMY,QAAQ,GAA0Bf,MAAM,CAACgB,GAAP,EAAxC;;MAEA,IAAI,CAACD,QAAD,IAAa,OAAOA,QAAP,KAAoB,UAArC,EAAiD;QAC/C,MAAM,IAAIE,KAAJ,CACJ,oEADI,CAAN;MAGD;;MAED,IAAIjB,MAAM,CAACkB,MAAP,GAAgB,CAApB,EAAuB;QACrB,MAAMC,UAAU,GAAGnB,MAAM,CAACgB,GAAP,EAAnB;;QAEA,IAAI,OAAOG,UAAP,KAAsB,UAA1B,EAAsC;UACpC,MAAM,IAAIF,KAAJ,CACJ,4FADI,CAAN;QAGD;;QAEDjB,MAAM,CAACoB,IAAP,CAAYD,UAAZ;MACD;;MAED,KAAKtB,IAAL,CAAUiB,IAAV,CACE,GAAGd,MADL,EAEE,CAACI,GAAD,EAAMO,GAAN,KAAa;QACX,IAAIP,GAAJ,EAAS;UACP,OAAOW,QAAQ,CAAC,gCAAYX,GAAZ,CAAD,EAAmB,IAAnB,CAAf;QACD;;QAEDW,QAAQ,CAAC,IAAD,EAAOJ,GAAP,CAAR;MACD,CARH,EASE,CAACP,GAAD,EAAMiB,KAAN,KAAe;QACb,IAAIjB,GAAJ,EAAS;UACP,OAAOD,MAAM,CAAC,gCAAYC,GAAZ,CAAD,CAAb;QACD;;QAEDF,OAAO,CAACmB,KAAD,CAAP;MACD,CAfH;IAiBD,CAtCM,CAAP;EAuCD;;AAtOmB;;AAAtBC","names":["Statement","constructor","stmt","getStatementInstance","bind","params","Promise","resolve","reject","err","reset","finalize","run","lastID","changes","get","row","all","rows","each","callback","pop","Error","length","positional","push","count","exports"],"sources":["../src/Statement.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}